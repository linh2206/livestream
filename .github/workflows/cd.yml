name: CD

on:
  push:
    branches: [main, develop]

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

env:
  DEPLOY_TIMEOUT: 300
  HEALTH_CHECK_TIMEOUT: 60
  MAX_RETRIES: 5

jobs:
  deploy-staging:
    name: Deploy to Staging (develop)
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    timeout-minutes: 15

    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Staging Server
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${{ secrets.STAGING_USERNAME || 'root' }}@${{ secrets.STAGING_HOST }} << 'EOF'
          set -euo pipefail

          echo "üöÄ Starting deployment to staging..."
          cd /workspace/livestream-staging

          # Backup current state
          echo "üì¶ Creating backup..."
          git stash push -m "backup-before-deploy-$(date +%Y%m%d-%H%M%S)" || true

          # Pull latest code
          echo "üì• Pulling latest code..."
          git fetch origin develop
          git reset --hard origin/develop

          # Stop services gracefully
          echo "‚èπÔ∏è Stopping services..."
          docker compose down --remove-orphans --timeout 30 || true

          # Build and start services with optimized build
          echo "üî® Building and starting services..."
          docker compose build --parallel --no-cache
          docker compose up -d --remove-orphans

          # Wait for services to be ready with smart wait
          echo "‚è≥ Waiting for services to start..."
          timeout 120 bash -c 'until docker compose ps | grep -q "healthy\|Up"; do sleep 5; done' || {
            echo "‚ùå Services failed to start within timeout"
            docker compose ps
            docker compose logs --tail=50
            exit 1
          }

          # Check service status
          echo "üìä Service status:"
          docker compose ps

          # Clean up old images
          echo "üßπ Cleaning up old images..."
          docker system prune -f --volumes

          echo "‚úÖ Staging deployment completed!"
          EOF

      - name: Health Check Staging
        run: |
          echo "üîç Performing comprehensive health checks..."

          # Wait for services to be fully ready
          sleep 10

          # Check nginx (public entrypoint)
          echo "Checking nginx health..."
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            if curl -f -s --max-time 10 http://${{ secrets.STAGING_HOST }}:${{ secrets.STAGING_PORT || '8080' }}/health > /dev/null; then
              echo "‚úÖ Nginx health check passed"
              break
            fi
            if [ $i -eq ${{ env.MAX_RETRIES }} ]; then
              echo "‚ùå Nginx health check failed after ${{ env.MAX_RETRIES }} attempts"
              exit 1
            fi
            echo "‚è≥ Nginx not ready, retrying in 5s... ($i/${{ env.MAX_RETRIES }})"
            sleep 5
          done

          # Check backend API health endpoint
          echo "Checking backend API health..."
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            if curl -f -s --max-time 10 http://${{ secrets.STAGING_HOST }}:${{ secrets.STAGING_PORT || '8080' }}/api/v1/health > /dev/null; then
              echo "‚úÖ Backend API health check passed"
              break
            fi
            if [ $i -eq ${{ env.MAX_RETRIES }} ]; then
              echo "‚ùå Backend API health check failed after ${{ env.MAX_RETRIES }} attempts"
              exit 1
            fi
            echo "‚è≥ Backend API not ready, retrying in 5s... ($i/${{ env.MAX_RETRIES }})"
            sleep 5
          done

          # Check frontend through nginx
          echo "Checking frontend through nginx..."
          for i in $(seq 1 3); do
            if curl -f -s --max-time 10 http://${{ secrets.STAGING_HOST }}:${{ secrets.STAGING_PORT || '8080' }}/ > /dev/null; then
              echo "‚úÖ Frontend health check passed"
              break
            fi
            if [ $i -eq 3 ]; then
              echo "‚ùå Frontend health check failed after 3 attempts"
              exit 1
            fi
            echo "‚è≥ Frontend not ready, retrying in 5s... ($i/3)"
            sleep 5
          done

          # Check backend ping endpoint
          echo "Checking backend ping endpoint..."
          curl -f -s --max-time 10 http://${{ secrets.STAGING_HOST }}:${{ secrets.STAGING_PORT || '8080' }}/api/v1/health/ping > /dev/null || {
            echo "‚ö†Ô∏è Backend ping endpoint not responding (non-critical)"
          }

          echo "‚úÖ All critical health checks passed!"

      - name: Rollback Staging on Failure
        if: failure()
        run: |
          echo "üîÑ Rolling back staging deployment..."
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${{ secrets.STAGING_USERNAME || 'root' }}@${{ secrets.STAGING_HOST }} << 'EOF'
          set -euo pipefail
          cd /workspace/livestream-staging

          # Restore from backup
          git stash pop || true

          # Restart with previous version
          docker compose down --remove-orphans --timeout 30
          docker compose up -d --remove-orphans

          # Wait for rollback to complete
          sleep 30
          docker compose ps

          echo "üîÑ Rollback completed"
          EOF

  deploy-production:
    name: Deploy to Production (main)
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 20

    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Production Server
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USERNAME }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          set -euo pipefail

          echo "üöÄ Starting deployment to production..."
          cd /workspace/livestream

          # Create backup with timestamp
          BACKUP_DIR="/workspace/backups/$(date +%Y%m%d-%H%M%S)"
          echo "üì¶ Creating backup in $BACKUP_DIR..."
          mkdir -p "$BACKUP_DIR"
          cp -r . "$BACKUP_DIR/" || true

          # Backup current git state
          git stash push -m "backup-before-deploy-$(date +%Y%m%d-%H%M%S)" || true

          # Pull latest code
          echo "üì• Pulling latest code..."
          git fetch origin main
          git reset --hard origin/main

          # Stop services gracefully
          echo "‚èπÔ∏è Stopping services..."
          docker compose down --remove-orphans --timeout 30 || true

          # Build and start services with optimized build
          echo "üî® Building and starting services..."
          docker compose build --parallel --no-cache
          docker compose up -d --remove-orphans

          # Wait for services to be ready with smart wait
          echo "‚è≥ Waiting for services to start..."
          timeout 180 bash -c 'until docker compose ps | grep -q "healthy\|Up"; do sleep 5; done' || {
            echo "‚ùå Services failed to start within timeout"
            docker compose ps
            docker compose logs --tail=50
            exit 1
          }

          # Check service status
          echo "üìä Service status:"
          docker compose ps

          # Show recent logs
          echo "üìã Recent logs:"
          docker compose logs --tail=20

          # Clean up old images (keep last 2)
          echo "üßπ Cleaning up old images..."
          docker image prune -f
          docker system prune -f --volumes

          echo "‚úÖ Production deployment completed!"
          EOF

      - name: Health Check Production
        run: |
          echo "üîç Performing comprehensive production health checks..."

          # Wait for services to be fully ready
          sleep 15

          # Check nginx (public entrypoint)
          echo "Checking nginx health..."
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            if curl -f -s --max-time 10 http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}/health > /dev/null; then
              echo "‚úÖ Nginx health check passed"
              break
            fi
            if [ $i -eq ${{ env.MAX_RETRIES }} ]; then
              echo "‚ùå Nginx health check failed after ${{ env.MAX_RETRIES }} attempts"
              exit 1
            fi
            echo "‚è≥ Nginx not ready, retrying in 5s... ($i/${{ env.MAX_RETRIES }})"
            sleep 5
          done

          # Check backend API health endpoint
          echo "Checking backend API health..."
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            if curl -f -s --max-time 10 http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}/api/v1/health > /dev/null; then
              echo "‚úÖ Backend API health check passed"
              break
            fi
            if [ $i -eq ${{ env.MAX_RETRIES }} ]; then
              echo "‚ùå Backend API health check failed after ${{ env.MAX_RETRIES }} attempts"
              exit 1
            fi
            echo "‚è≥ Backend API not ready, retrying in 5s... ($i/${{ env.MAX_RETRIES }})"
            sleep 5
          done

          # Check frontend through nginx
          echo "Checking frontend through nginx..."
          for i in $(seq 1 3); do
            if curl -f -s --max-time 10 http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}/ > /dev/null; then
              echo "‚úÖ Frontend health check passed"
              break
            fi
            if [ $i -eq 3 ]; then
              echo "‚ùå Frontend health check failed after 3 attempts"
              exit 1
            fi
            echo "‚è≥ Frontend not ready, retrying in 5s... ($i/3)"
            sleep 5
          done

          # Check backend ping endpoint
          echo "Checking backend ping endpoint..."
          curl -f -s --max-time 10 http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}/api/v1/health/ping > /dev/null || {
            echo "‚ö†Ô∏è Backend ping endpoint not responding (non-critical)"
          }

          # Check monitoring endpoints
          echo "Checking monitoring endpoints..."
          curl -f -s --max-time 10 http://${{ secrets.PRODUCTION_HOST }}:8000 > /dev/null || {
            echo "‚ö†Ô∏è Grafana not responding (non-critical)"
          }
          curl -f -s --max-time 10 http://${{ secrets.PRODUCTION_HOST }}:9090 > /dev/null || {
            echo "‚ö†Ô∏è Prometheus not responding (non-critical)"
          }

          echo "‚úÖ All critical production health checks passed!"

      - name: Rollback Production on Failure
        if: failure()
        run: |
          echo "üîÑ Rolling back production deployment..."
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USERNAME || 'root' }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          set -euo pipefail
          cd /workspace/livestream

          # Restore from backup
          git stash pop || true

          # Restart with previous version
          docker compose down --remove-orphans --timeout 30
          docker compose up -d --remove-orphans

          # Wait for rollback to complete
          sleep 45
          docker compose ps
          docker compose logs --tail=10

          echo "üîÑ Production rollback completed"
          EOF

      - name: Deployment Success Notification
        if: success()
        run: |
          echo "üéâ Production deployment successful!"
          echo "üåê Application is available at: http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}"
          echo "üìä Monitoring: http://${{ secrets.PRODUCTION_HOST }}:8000 (Grafana)"
          echo "üìà Metrics: http://${{ secrets.PRODUCTION_HOST }}:9090 (Prometheus)"
          echo "üè• Health Check: http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}/api/v1/health"
          echo "üîç Ping: http://${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PORT || '8080' }}/api/v1/health/ping"
